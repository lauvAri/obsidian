## 路径长度
从树中一个结点到另一个结点之间**分支的数目**
## 树的路径长度
- 从根结点到每一结点的**路径长度之和**
- **完全二叉树的路径长度最短**
## 结点的加权路径长度
从根结点出发到达结点的路径长度乘结点权值
## 树的加权路径长度（weighted path length / WPL）
到各叶子结点的路径长度乘叶子结点权值再求和
## 哈夫曼树、最优二叉树、最佳判断树
- **WPL最小**的二叉树
- 对同一组结点来说，**哈夫曼树可以是不唯一的**（存在相同元素时），但是最小带权长度一定是唯一的
- 哈父曼树**不存在度为1的结点**，权值越高的结点相对来说越接近根节点
- 哈夫曼树的构建思想是**反复选择两个最小的元素，合并，直到只剩下一个元素**，如果有n个结点，需要执行n-1次合并操作，而每次合并会多出一个结点，所以最终会多出n-1个结点，再加上n个叶子结点，则哈夫曼树一共有**2n-1**个结点
- 一般来说可以用**优先队列、堆结构**执行这种策略
## 哈夫曼编码
- 将电文以01序列传送
- 方法一：等长的二进制编码
- 方法二：不等长的二进制编码
	- A: 010  B: 0101  C: 01011 
- 把二叉树上所有分支都进行编号，**左分支标为0**，**右分支标为1**，从根结点出发任意一个结点的分支序列会得到一个编号
- 这样，对于任何一个叶子结点，其编号一定不会成为其他任何一个结点编号的**前缀**
- 任何一个字符的编码都不是另一个字符的编码的前缀，这样的编码成为**前缀编码**
- 一个字符串中各字符的**频数作为各自叶子结点的权值**，那么字符串编码为01串后的长度实际上即为这棵树的带权路径长度
- 由哈夫曼树产生的编码方式即哈夫曼编码，哈夫曼编码是可以让字符串编码为01串后长度最短的前缀编码



